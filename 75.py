from math import sqrt
import time
start_time = time.time()
# print()

def nod(a,b):
    return a if b == 0 else nod(b, a % b)

L = 1500000
# L = 120

N = []
M = []
T = []

for n in range(1,round(sqrt(L))):
    for m in range(n+1,round(sqrt(L))):
        if (m-n)%2==1: #and nod(m,n)==1:
            a = m*m - n*n
            b = 2*m*n
            c = m*m + n*n
            p = a + b + c
            # print(p)
            if p <= L and nod(m,n)==1:
                k = 1
                while k*p <= L:
                    T.append(k*p)
                    k += 1

Total = 0
mL = L//2
D1 = [0]*mL
D2 = [0]*mL

for x in T:
    if x < mL:
        D1[x] += 1
    else:
        D2[mL-x] += 1

for x in range(mL):
    if D1[x] == 1:
        Total += 1
    if D2[x] == 1:
        Total += 1

print(Total)

print("--- %s seconds ---" % (time.time() - start_time))

# 75
"""

a = k*(m*m-n*n)
b = k*(2*m*n)
c = k*(m*m+n*n)

m,n,k натуральные, m > n, m-n нечетно, m и n взаимно просты
p = a+b+c = L

1. нужна последовательность m,n
+ создать список всех треугольников по формуле
+ сразу создать список из периметров
3. кол-во уникальных

Оказывается, что 12 см - наименьшая длина проволоки, сгибая которую, можно получить прямоугольный треугольник с целыми сторонами, притом лишь единственным способом. Есть и другие примеры.

12 см: (3,4,5)
24 см: (6,8,10)
30 см: (5,12,13)
36 см: (9,12,15)
40 см: (8,15,17)
48 см: (12,16,20)
Если p - периметр прямоугольного треугольника с целочисленными длинами сторон {a,b,c}, то существует ровно три решения для p = 120:

{20,48,52}, {24,45,51}, {30,40,50}

Известно, что длина проволоки составляет L. Для скольких значений L ≤ 1 500 000, сгибая проволоку, можно получить ровно один прямоугольный треугольник с целыми сторонами?

Примечание: Эта задача была недавно изменена. Убедитесь в том, что вы используете правильные параметры.


161667
"""
